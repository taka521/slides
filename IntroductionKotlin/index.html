<DOCTYPE html>
    <html>

    <head>
        <title>タイトル</title>
        <meta charset="utf-8">
        <style>
            <style>@import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
            @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
            @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

            body {
                font-family: 'Droid Serif';
            }

            h1,
            h2,
            h3 {
                text-align: center;
                color: #006cb4;
                font-weight: 700;
            }

            .remark-slide-content h1 {
                font-size: 3em;
            }

            .remark-slide-content h2 {
                font-size: 2em;
            }

            .remark-slide-content h3 {
                font-size: 1.4em;
            }

            .footnote {
                position: absolute;
                bottom: 1em;
            }

            /* リンク */
            a,
            a>code,
            p a {
                color: #ff1a75;
                text-decoration: none;
                font-size: 100%;
            }

            /* コード */
            code {
                font-family: 'Ubuntu Mono';
                border-radius: 5px;
                -web-border-radius: 5px;
                font-size: 90%
            }

            .remark-code,
            .remark-inline-code {
                font-size: 85%;
                color: #660000;
                font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace;
                background-color: #eeeeee;
            }

            .remark-code-line-highlighted {
                background-color: #eeeeee;
            }

            .pull-left {
                float: left;
                width: 47%;
            }

            .pull-right {
                float: right;
                width: 47%;
            }

            .pull-right~p {
                clear: both;
            }

            /* タイトルページ */
            .inverse {
                background: #006cb4;
                color: #CCC;
            }

            .inverse h1,
            .inverse h2 {
                color: #f3f3f3;
                line-height: 1em;
            }

            /* 左右二段表示 */
            .left-column {
                width: 48%;
                float: left;
            }

            .right-column {
                width: 48%;
                float: right;
            }

            p,
            li {
                font-size: 150%;
            }

            /* リスト内のリストは文字を小さく */
            ul li ul li,
            ol li ul li {
                font-size: 75%;
            }
        </style>
    </head>

    <body>
        <textarea id="source">
class: center, middle
## Introduction Kotlin


---
class: middle

## Agenda

* Kotlinとは
* Kotlinの特徴
* Q & A
* まとめ

---
class: middle

## Kotlinとは

--
class: middle

* 2011年に登場した静的型付けのOOP言語。
  * 開発元はJetBrains社（IntelliJの会社）
  * 現時点のバージョンは1.3.50
* 2017年にAndroidの公式開発言語として採用。
* JVM上で動作し、Javaとは相互運用可能。
	* 豊富なJavaのライブラリをそのままKotlinで使うことができる。
* Java経験者はKotlinの学習コストはかなり低い。
	* Kotlin特有の機能を使わずとも、better javaとしても書くことができる。
* SpringFrameworkも公式にKotlin対応している。
	* ただし、Kotlin対応はSpring5.0以降。（Spring Boot だと2.0.0以降が、Spring5に対応）

---
class: middle

## Kotlinの特徴

---
class: middle

### Kotlinの特徴

Kotlinには様々な機能がありますが、その中でも個人的に有用だと思う機能について2つほど紹介。

* Null安全
* Data Class

---
class: middle

## Null安全

---
class: middle

### Kotlinの特徴 - Null安全

Kotlinは Null になる可能性のある変数が、適切に処理されるかをコンパイル時にチェックし、実行時にNPEが発生しないことを保障する。
このように

** "Nullチェックの強制" と "チェック方法の妥当性" がコンパイラによってチェックされる仕組み**

を **NULL安全** と呼ぶ。（NULLを回避することを指すのではないので注意）


---
class: middle

### Kotlinの特徴 - Null安全

Kotlinはデフォルトで変数へのNULL代入を許可しない。  
また、NULLを許容する変数を操作する場合は **「操作時に、変数がNULLでないことを保証する」** 必要がある。

```Kotlin
// 非NULL許容型の変数定義
var message: String = "Hello World"
message = null // コンパイルエラー
```

---
class: middle

### Kotlinの特徴 - Null安全

ただ、Javaとの相互運用の都合上、Nullableな変数を宣言したいケースが出てくる。  
その場合は型宣言の後ろに `?` を付加することで、Nullableな変数として扱うことが可能となる。

```kotlin
// NULL許容型の変数定義
var message: String? = null // OK
```

<small>※ちなみに `String` と `String?` は全く別の型なので同一視しないように。</small>  
ただし、先程記載した通り「操作時に、変数がNULLでないことを保証する」する必要がある。  
具体的な方法としては

---
class: middle

### Kotlinの特徴 - Null安全

```kotlin
var msg: String? = null

// if による nullチェック （無難だけど、スマートじゃない）
if (msg != null) message.length

// 安全呼び出し（?.）の利用
// 変数がnullの場合、メソッドは実行されずにnullが返る。
msg?.length

// エルビス演算子（?:）の利用
// 変数がnullの場合、メソッドは実行されずに ?: の後に続く値が返る。（よく使う）
msg?.length ?: -1

// 強制アンラップ（!!）の利用
// 強制的に非NULL許容型として扱い、メソッドを実行する。
//（よっぽどのことがない限り使わない）
msg!!.length
```

こんな感じで、Kotlinはnullに対する対策と解決方法を提供している。

---
class: middle

## Data Class

---
class: middle

### Kotlinの特徴 - Data Class

Kotlinには「データとして値を保持するためだけのクラス」を簡単に宣言できる、`Data class` という機能がある。
Javaだと、よくDTO（Data Transfer Object）といったデザインパターン名で呼ばれている。


---
class: middle

### Kotlinの特徴 - Data Class

Kotlinの場合、通常のクラス宣言でもgetter／setterは自動で生えるが、Data classを利用したクラスはそれだけではない。
Data classによって宣言されたクラスには、以下のメソッドが自動で生成される。

* プロパティのgetter, setter
* `equals`、`hashCode`、`toString`
* `componentN` メソッド
* インスタンスのコピー作成する`copy`メソッド

---
class: middle

### Kotlinの特徴 - Data Class

getter, setterの生成に関しては特に言及することが無いので省略。  
`equals`、`hashCode`、`toString` については、適切にオーバライドされたメソッドが生える。  

特に `equals` と `hashCode` は自前で実装するとそれなりに記述量が多く、
且つ「一般契約」と呼ばれる「`equals`をオーバライドする場合の決まり事」に従う必要がある。
（一般契約に従わないと余裕でバグるので、JavaだとIDEに自動生成してもらうのが良い）

---
class: middle

### Kotlinの特徴 - Data Class

`componentN` メソッドとは、各プロパティをgetterではなく `component1`, `component2` といった形で取得できるメソッド。
何が嬉しいかというと、以下のように「あるインスタンスから、一部だけを別の変数に代入したい」ケースが容易に実現可能。

```kotlin
data class User(val name: String, val age: Int, val gender: Gender)

val user = User("田中", 20, Gender.MAN)
val (name, age) = user;
```

---
class: middle

### Kotlinの特徴 - Data Class

この`componentN`、具体的には `分割宣言(Destructuring Declarations)` という機能で、JSでいう分割代入に近いが、JSほど便利ではない。  
（ちなみに、`componentN`というメソッド名にすると分割宣言が有効になるわけではない）

---
class: middle

### Kotlinの特徴 - Data Class

例えばJSの分割代入は

```js
// 先頭だけ個別、残りは配列のまま分割代入
const arry = [1, 2, 3];
const [a, ...b] = array; // a = 1, b = [2, 3]

// キーワードで分割代入
const obj = { name: "田中", age: 20, gender: "man" };
const {name, gender} = obj; // name = "田中", gender = "man"
```

といった柔軟なことができるが、Kotlinの分割宣言は上記のようなことができない。  
あくまでも「プロパティの宣言順に値を取得できる機能」に過ぎないが、多少は便利かも？

---
class: middle

### Kotlinの特徴 - Data Class

`copy`メソッドは、その名前の通りインスタンスのコピーを行うメソッド。
`copy`メソッドは一部のプロパティだけを変更したインスタンスを作成することができる。

```kt
data class User(val name: String, val age: Int, val gender: Gender)

// 20歳 男性 田中さん
val tanaka = User("田中", 20, Gender.MAN) 

// 色々あって姓が 佐藤 へ
val satoPh2 = tanaka.copy(name = "佐藤") 

// 色々あって、佐藤さんは30歳で女性へ
val satoPh3 = satoPh2.copy(age = 30, gender = Gender.WOMAN) 
```

---
class: middle

### Kotlinの特徴 - Data Class

`copy`メソッドが利用できると

1. DBからデータを抽出
2. 抽出したデータの一部を変更してUPDATE
3. 1 のデータを使って後続の処理を実施

といったケースに対して容易に対応できる。
（Javaだと、手順2で新しくインスタンスを生成して、１つずつプロパティを詰め替える必要がある）

---
class: middle

### Kotlinの特徴 - Data Class

ちなみに「データとして値を保持するためだけのクラス」の実装をKotlinとJavaで比較した場合、圧倒的にKotlinの方が記述量が少ないです。
例えば、`User` という「ID」「名前」「年齢」を持つだけのクラスをJavaで定義すると約60行になります。

[User.java - gist](https://gist.github.com/taka521/d03352edb8e5e05c3a48284cabb89042)

上記と同様のクラスをKotlinのdata classで定義すると

```kt
 data class User(val id: Long, val name: String, val age: Int)
```

1行で終わります。
かつ、`componentN`や`copy`メソッドといった便利メソッドもおまけでついてきます。

---
class: middle

### Kotlinの特徴

Kotlinには他にも

* 文字列テンプレート
  * 文字列に変数を埋め込めるやつ
* 拡張関数
  * 既存クラスに新しいメソッドを生やすやつ
* 高階関数
  * 関数の引数や戻り値に関数を指定できるやつ
* Sealed Classes
  * 同一ファイル内でのみ継承可能

など、様々な機能が備わっているので、気になったら調べてみてください。
どれも「こんなのがJavaに欲しかった」機能ばかりです。

---
class: middle

## Q & A


---
class: middle

## まとめ

        </textarea>
        <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript"></script>
        <script type="text/javascript">
            var slideshow = remark.create({
                ratio: '4:3'
            });
        </script>
    </body>
</html>
