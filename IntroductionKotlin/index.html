<DOCTYPE html>
    <html>

    <head>
        <title>タイトル</title>
        <meta charset="utf-8">
        <style>
            <style>@import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
            @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
            @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

            body {
                font-family: 'Droid Serif';
            }

            h1,
            h2,
            h3 {
                text-align: center;
                color: #006cb4;
                font-weight: 700;
            }

            .remark-slide-content h1 {
                font-size: 3em;
            }

            .remark-slide-content h2 {
                font-size: 2em;
            }

            .remark-slide-content h3 {
                font-size: 1.4em;
            }

            .footnote {
                position: absolute;
                bottom: 1em;
            }

            /* リンク */
            a,
            a>code,
            p a {
                color: #ff1a75;
                text-decoration: none;
                font-size: 100%;
            }

            /* コード */
            code {
                font-family: 'Ubuntu Mono';
                border-radius: 5px;
                -web-border-radius: 5px;
                font-size: 90%
            }

            .remark-code,
            .remark-inline-code {
                font-size: 85%;
                color: #660000;
                font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace;
                background-color: #eeeeee;
            }

            .remark-code-line-highlighted {
                background-color: #eeeeee;
            }

            .pull-left {
                float: left;
                width: 47%;
            }

            .pull-right {
                float: right;
                width: 47%;
            }

            .pull-right~p {
                clear: both;
            }

            /* タイトルページ */
            .inverse {
                background: #006cb4;
                color: #CCC;
            }

            .inverse h1,
            .inverse h2 {
                color: #f3f3f3;
                line-height: 1em;
            }

            /* 左右二段表示 */
            .left-column {
                width: 48%;
                float: left;
            }

            .right-column {
                width: 48%;
                float: right;
            }

            p,
            li {
                font-size: 150%;
            }

            /* リスト内のリストは文字を小さく */
            ul li ul li,
            ol li ul li {
                font-size: 75%;
            }
        </style>
    </head>

    <body>
        <textarea id="source">
class: center, middle
## Introduction Kotlin


---
class: middle

## Agenda

* Kotlinとは
* Kotlinの特徴
* Q & A
* まとめ

---
class: middle

## Kotlinとは

--
class: middle

* 2011年に登場した静的型付けのOOP言語。
  * 開発元はJetBrains社（IntelliJの会社）
  * 現時点のバージョンは1.3.50
* 2017年にAndroidの公式開発言語として採用。
* JVM上で動作し、Javaとは相互運用可能。
	* 豊富なJavaのライブラリをそのままKotlinで使うことができる。
* Java経験者はKotlinの学習コストはかなり低い。
	* Kotlin特有の機能を使わずとも、better javaとしても書くことができる。
* SpringFrameworkも公式にKotlin対応している。
	* ただし、Kotlin対応はSpring5.0以降。（Spring Boot だと2.0.0以降が、Spring5に対応）

---
class: middle

## Kotlinの特徴

---
class: middle

### Kotlinの特徴

Kotlinには様々な機能がありますが、その中でも個人的に有用だと思う機能について2つほど紹介。

* null安全
* Data Class

---
class: middle

## null安全

---
class: middle, center

### Kotlinの特徴 - null安全

**null is guilty.**


---
class: middle

### Kotlinの特徴 - null安全

Kotlinは null になる可能性のある変数が、適切に処理されるかをコンパイル時にチェックし、実行時にNPEが発生しないことを保障する。
このように

** "nullチェックの強制" と "チェック方法の妥当性(網羅性)" がコンパイラによってチェックされる仕組み**

を **null安全** と呼ぶ。（小手先のテクニックでnullを回避することを指すのではないので注意）


---
class: middle

### Kotlinの特徴 - null安全

Kotlinはデフォルトで変数へのnull代入を許可しない。（非null許容型）  
また、nullを許容する変数（null許容型）を操作する場合は **「操作時に、変数がnullでないことを保証する」** 必要がある。

```Kotlin
// 非null許容型の変数定義
var message: String = "Hello World"
message = null // コンパイルエラー
```

---
class: middle

### Kotlinの特徴 - null安全

ただ、nullableな変数を宣言したいケースが出てくる。  
その場合は型宣言の後ろに `?` を付加することで、nullableな変数として扱うことが可能となる。

```kotlin
// null許容型の変数定義
var message: String? = null // OK
```

<small>※ちなみに `String` と `String?` は全く別の型なので同一視しないように。</small> 

ただし、先程記載した通り「操作時に、変数がnullでないことを保証する」する必要がある。  
具体的な方法としては...

---
class: middle

### Kotlinの特徴 - null安全

```kotlin
var msg: String? = null

// if による nullチェック （無難だけど、スマートじゃない）
if (msg != null) message.length

// 安全呼び出し（?.）の利用
// 変数がnullの場合、メソッドは実行されずにnullが返る。
msg?.length

// エルビス演算子（?:）の利用
// 左辺の評価結果がnullの場合 ?: の後に続く値が返る。（よく使う）
msg?.length ?: -1

// 強制アンラップ（!!）の利用
// 強制的に非null許容型として扱い、メソッドを実行する。
// （よっぽどのことがない限り使わない）
msg!!.length
```

こんな感じで、Kotlinはnullに対する対策と解決方法を提供している。

---
class: middle

## Data Class

---
class: middle

### Kotlinの特徴 - Data Class

Kotlinには

### データとして値を保持するためだけのクラス

を簡単に宣言できる、`Data Class` という機能（クラス定義方法）がある。  

```kotlin
data class User(val id: Long, val name: String, val age: Int)
```

上記のクラスとほぼ同様の実装をJavaで行うと約60行になる。

[User.java - gist](https://gist.github.com/taka521/d03352edb8e5e05c3a48284cabb89042)


---
class: middle

### Kotlinの特徴 - Data Class

Javaから見たときの`Data Class`最大の利点は「記述力が少ない」なのだが、おまけで以下のメソッドも自動的に生成される。

* getter, setter
* `equals`, `hashCode`, `toString` メソッド
* `componentN` メソッド
* `copy`メソッド

getter, setter以外を、順番に説明していきます。  
<small>※なお、通常のクラス宣言でもgetter, setterは自動で生えます</small>

---
class: middle

### Kotlinの特徴 - Data Class

〜`equals`, `hashCode`, `toString`〜

単なるDTO(Data Transfer Object)の場合は、そこまで有用ではない。  
ただ、値クラス(ValueObject)のように論理等価性が求められるような場合は非常に有用。  

どういうことかと言うと...

---
class: middle

### Kotlinの特徴 - Data Class

`Object#equals`は参照値の比較を行っているので、  
単なるクラス宣言だと

```kotlin
class Money(val value: Int) // お金を表す型

val moneyA = Money(100) // 100円
val moneyB = Money(100) // 100円

moneyA == moneyB
```

は `false` になる。  
<small>※kotlinの場合 `==` が `equals` と同じ</small>

---
class: middle, center

# 🤔🤔🤔

100円は100円でしょ...

---
class: middle, center

じゃあ自前で`equals`をオーバライドすると...

---
class: middle

```kotlin
class Money(val value: Int) {

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Money) return false

        if (value != other.value) return false

        return true
    }

    override fun hashCode(): Int {
        return value
    }

    override fun toString(): String {
        return "Money(value=$value)"
    }
    
}
```

---
class: middle, center

長い

---
class: middle

### Kotlinの特徴 - Data Class

`equals`を自前で実装すると、プロパティ数に比例して記述量が多くなる。  
また、`equals`をオーバライドする場合には、

* 一般契約

と呼ばれる「`equals`をオーバライドする場合の決まり事」に従う必要がある。 

<small>※一般契約に従わないと余裕でバグる（例えば`HashMap`や`HashSet`は一般契約に従ったクラスを扱うことを前提に設計されている）ので、IDEに自動生成してもらうのが良い。</small>


---
class: middle

### Kotlinの特徴 - Data Class

`data class`としてクラス定義することで、面倒な実装や制約のことを気にする必要がなくなる。

あとは `toString` が

```kotlin
println(Money(100).toString()) // => Money(value=100)
```

という感じで有用な文字列表現を返してくれるので嬉しい。


<small>ログに↓みたいなのが出力されてるシステム見たことアルヨ...</small>

```kotlin
com.example.Hoge@8a50f1cc
```

---
class: middle

### Kotlinの特徴 - Data Class

〜`componentN`〜

各プロパティをgetterではなく  
`component1()`, `component2()`, ...  
といった感じで、N番目のプロパティを取得するメソッドが生える。

---
class: middle

### Kotlinの特徴 - Data Class

何が嬉しいかというと、以下のように「あるインスタンスから、プロパティの一部を別の変数に代入したい」ケースに対応できる。

```kotlin
data class User(val name: String, val age: Int, val gender: Gender)

// 名前と性別だけ抽出（年齢は不要）
val user = User("田中", 20, Gender.MAN)
val (name, _, gender) = user

// ラムダの引数に、一部のプロパティだけ渡す
val users: List<User> = ...
users.map { (name, age) -> 
    ...
}
```


---
class: middle

### Kotlinの特徴 - Data Class

この`componentN`、具体的には 

### 分解宣言(Destructuring Declarations)

という機能で、JSでいう分割代入に近い。  

<small>
※ちなみに、`componentN`というメソッド名にすると分解宣言が有効になるわけではなく、
`componentN`を`operator`修飾する必要がある。
</small>

```kotln
operator fun component1() ...
operator fun component2() ... 
```

<small>`operator` + `componentN` = 分解宣言</small>

---
class: middle

### Kotlinの特徴 - Data Class

〜おまけ〜 

JSの分割代入は

```js
// 先頭だけ個別、残りは配列のまま分割代入
const arry = [1, 2, 3];
const [a, ...b] = array; // a = 1, b = [2, 3]

// キーワードで分割代入
const obj = { name: "田中", age: 20, gender: "man" };
const {name, gender} = obj; // name = "田中", gender = "man"
```

といった柔軟なことができるが、Kotlinの分割宣言は上記のようなことは出来ない。惜しい。


---
class: middle

### Kotlinの特徴 - Data Class

〜`copy`〜

その名前の通りインスタンスのコピーを行うメソッド。
`copy`メソッドは一部のプロパティだけを変更したインスタンスを作成することができる。

```kt
data class User(val name: String, val age: Int, val gender: Gender)

// 20歳 男性 田中さん
val tanaka = User("田中", 20, Gender.MAN) 

// 色々あって姓が 佐藤 へ
val satoPh2 = tanaka.copy(name = "佐藤") 

// 色々あって、佐藤さんは30歳で女性へ
val satoPh3 = satoPh2.copy(age = 30, gender = Gender.WOMAN) 
```

---
class: middle

### Kotlinの特徴 - Data Class

`copy`メソッドが利用できると

1. DBからデータを抽出
2. 抽出したデータの一部を変更してUPDATE
3. 1 のデータを使って後続の処理を実施

といったケースに対して容易に対応できる。  
プロパティ数が多い場合、Javaだとインスタンスのコピーは面倒なので非常に有用なメソッド。  
※特にimmutableなクラスだと尚更有用

---
class: middle

### Kotlinの特徴

Kotlinには他にも

* 文字列テンプレート
  * 文字列に変数を埋め込めるやつ
* 拡張関数
  * 既存クラスに新しいメソッドを生やすやつ
* 高階関数
  * 関数の引数や戻り値に関数を指定できるやつ
* Sealed Classes
  * 同一ファイル内でのみ継承可能

など、様々な機能が備わっているので、気になったら調べてみてください。
どれも「こんなのがJavaに欲しかった」機能ばかりです。

---
class: middle

## Q & A


---
class: middle

## まとめ

* Java経験者の学習コストは低い
* null安全やdata classなど、有用な機能が豊富
* Kotlinはいいぞ

---
class: middle

## Kotlinはいいぞ

---
class: middle, center

## ご静聴、ありがとうございました

質問があれば答えます！

---
class: middle

## 参考



        </textarea>
        <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript"></script>
        <script type="text/javascript">
            var slideshow = remark.create({
                ratio: '4:3'
            });
        </script>
    </body>
</html>
