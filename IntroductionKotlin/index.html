<DOCTYPE html>
  <html>

  <head>
    <title>Introduction Kotlin</title>
    <meta charset="utf-8">
    <style>
      <style>@import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-size: 100%;
        font-family: 'Droid Serif';
      }

      h1,
      h2,
      h3 {
        text-align: center;
        color: #006cb4;
        font-weight: 700;
      }

      .remark-slide-content h1 {
        font-size: 3rem;
      }

      .remark-slide-content h2 {
        font-size: 2rem;
      }

      .remark-slide-content h3 {
        font-size: 1.4rem;
      }

      .remark-slide-content {
        padding: 1em 3em 1em 3em;
      }

      .footnote {
        position: absolute;
        bottom: 1em;
      }

      /* リンク */
      a,
      a>code,
      p a {
        color: #ff1a75;
        text-decoration: none;
        font-size: 1.0rem;
      }

      /* コード */
      code {
        font-family: 'Ubuntu Mono';
        border-radius: 5px;
        -web-border-radius: 5px;
        font-size: 0.9rem;
      }

      .remark-code,
      .remark-inline-code {
        font-size: 1.0rem;
        color: #660000;
        font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace;
        background-color: #eeeeee;
      }

      .remark-code-line-highlighted {
        background-color: #eeeeee;
      }

      .pull-left {
        float: left;
        width: 47%;
      }

      .pull-right {
        float: right;
        width: 47%;
      }

      .pull-right~p {
        clear: both;
      }

      /* タイトルページ */
      .inverse {
        background: #006cb4;
        color: #CCC;
      }

      .inverse h1,
      .inverse h2 {
        color: #f3f3f3;
        line-height: 1em;
      }

      /* 左右二段表示 */
      .left-column {
        width: 48%;
        float: left;
      }

      .right-column {
        width: 48%;
        float: right;
      }

      p,
      li {
        font-size: 1.2rem;
        margin-top: 0.15rem;
        margin-bottom: 0.15rem;
      }

      /* リスト内のリストは文字を小さく */
      ul li ul li,
      ol li ul li {
        font-size: 1.0rem;
        margin-top: 0.15rem;
        margin-bottom: 0.15rem;
      }
    </style>
  </head>

  <body>
    <textarea id="source">
class: center, middle

# Introduction Kotlin


---
class: middle

## はじめに

* メモとかは取らなくていいです。（後ほど資料は展開します）
* 質問は随時受け付けます。

---
class: middle

## Agenda

* Kotlinとは
* Kotlinの特徴
* まとめ


---
class: middle

## Kotlinとは

--
class: middle

* 2011年に登場した静的型付けのOOP言語。
  * 現時点のバージョンは1.3.50
  * 実用性（読みやすさ、再利用性、相互運用性）を大事にしている。
* 2017年にAndroidの公式開発言語として採用。
* JVM上で動作し、Javaとは相互運用可能。
	* 豊富なJavaのライブラリをそのままKotlinで使うことができる。
* Java経験者はKotlinの学習コストはかなり低い。
    * Kotlin特有の機能を使わずとも、better javaとしても書くことができる。
    * 勿論「Kotlinらしく」書くのであれば、学習コストはかかる。
* SpringFrameworkも公式にKotlin対応している。
    * ただし、Kotlin対応は Spring5 以降。
    * SpringBoot2.0.0 以降が、Spring5を扱っている。

---
class: middle

## Kotlinの特徴

---
class: middle

### Kotlinの特徴

Kotlinには様々な特徴（機能）がありますが、  
その中でも個人的に有用だと思うものについて、3つ紹介します。

* 記述量が少ない
* null安全
* Data Class

---
class: middle

## 記述量が少ない

---
class: middle

### Kotlinの特徴 - 記述量が少ない

これはJavaと比較した場合になりますが、基本的に記述量が少ないです。  
ある処理をJavaとKotlinで記述した場合、  
個人的な感覚としては、約30% ~ 50%程 Kotlinの方が少なく済みます。

<br>

~ はろーわーるど比較 ~

<br>

Java
```java
public class Main {
    public static void main(String...args) {
        System.out.println("Hello World");
    }
}
```

<br>

Kotlin
```kotlin
fun main() = println("Hello World")
```

---
class: middle

### Kotlinの特徴 - 記述量が少ない


IntelliJ には JavaのコードをKotlinに変換する機能がついているので、  
試しに弊社の１プロジェクトを丸っとKotlinにコンバードしてみました。

<br>

👉 対象としたプロジェクトの総コード数は 81,347行 でした。

<br>

--

結果は...

---
class: middle

<br>

## Kotlin : 56,884行

<br><br>


---
class: middle

<br>

## 81,347行  ->  56,884行

<br>

<center>👉 約30%の削減</center>


---
class: middle

### Kotlinの特徴 - 記述量が少ない

機械的に変換しただけなので冗長な部分がありますが、  
綺麗にお掃除すれば更に5% ~ 10%は削ることが出来ると思います。

---
class: middle

### Kotlinの特徴 - 記述量が少ない

* 勿論学習コストはかかる（言語が異なるので当たり前）
* ただ、Javaよりもよりも簡潔で可読性の高いコードが書ける


<br>

👉 短期間で学習コストはペイできる  
👉 更に、Java経験者であれば、Kotlinの学習コストは小さい

---
class: middle

## null安全

---
class: middle, center

偉い人は言いました..

--

**null is guilty.**

---
class: middle

### Kotlinの特徴 - null安全

Kotlinはデフォルトで変数へのnull代入を許可しない。

👉 **非null許容型**

<br>

```kotlin
var message: String = "Hello World"
message = null // compile error!
```

---
class: middle

### Kotlinの特徴 - null安全

nullbaleな変数を宣言することもできる。  
nullableな変数を宣言する場合は、データ型の後ろに `?` をつける。

👉 **null許容型**

<br>

```kotlin
var message: String? = "Hello World"
message = null // OK!
```

<small>※ちなみに、`String` と `String?` は全く別の型。</small>

---
class: middle

### Kotlinの特徴 - null安全

ただし、null許容型は**「操作時に、変数がnullでないことを保証する」**必要がある。  
具体的な方法としては...


---
class: middle

### Kotlinの特徴 - null安全

```kotlin
// if による nullチェック
if (msg != null) message.length
```

--

```kotlin
// 安全呼び出し（?.）の利用
// 変数がnullの場合、メソッドは実行されずにnullが返る。
msg?.length
```

--

```kotlin
// エルビス演算子（?:）の利用
// 左辺の評価結果がnullの場合 ?: の後に続く値が返る。
msg?.length ?: -1
```

--

```kotlin
// 強制アンラップ（!!）の利用
// 強制的に非null許容型として扱い、メソッドを実行する。
msg!!.length
```

--

こんな感じ

---
class: middle

### Kotlinの特徴 - null安全

Kotlinは null が適切に処理されるかをコンパイル時にチェックし、  
実行時にNPEが発生しないことを保証している。(ただし、Kotlinに限る)

<br>

👉 Kotlinの関数をJavaから呼び出す場合には、NPEが発生する可能性があるので注意

---
class: middle

### Kotlinの特徴 - null安全

このように

<br>

** "nullチェックの強制" と "チェック方法の妥当性(網羅性)" がコンパイラによってチェックされる仕組み**

<br>

を **null安全** と呼ぶ。

<br>

👉null安全呼び出し(`?.`)やエルビス演算子(`?:`)が使われていることが null安全 なのでは **ない** です。


---
class: middle

## Data Class

---
class: middle

### Kotlinの特徴 - Data Class

Kotlinには

### データとして値を保持するためだけのクラス

を簡単に宣言できる、`Data Class` という機能（クラス定義方法）がある。  

<br>

👉 Javaプロジェクトにおける総行数のうち、1/2 ~ 1/3がDTOなんてことないですか？


---
class: middle

### Kotlinの特徴 - Data Class

ID、名前、年齢 を持つ `User` というDTOを`Data Class`で定義すると...

<br>

```kotlin
data class User(val id: Long, val name: String, val age: Int)
```

<br>

１行で済む。  
上記のクラスとほぼ同様の実装をJavaで行うと約60行になる。

<br>

👉 [User.java - gist](https://gist.github.com/taka521/d03352edb8e5e05c3a48284cabb89042)


---
class: middle

### Kotlinの特徴 - Data Class

Javaから見たときの`Data Class`最大の利点は「記述力が少ない」なのだが、おまけで以下のメソッドも自動的に生成される。

* getter, setter
* `equals`, `hashCode`, `toString` メソッド
* `componentN` メソッド
* `copy`メソッド

getter, setter以外を、順番に説明していきます。  
<small>※なお、通常のクラス宣言でもgetter, setterは自動で生えます</small>

---
class: middle

### Kotlinの特徴 - Data Class

#### ~ `equals`, `hashCode`, `toString` ~

単なるDTO(Data Transfer Object)の場合は、そこまで有用ではない。  
ただ、値クラス(ValueObject)のように論理等価性が求められるような場合は非常に有用。  

どういうことかと言うと...

---
class: middle

### Kotlinの特徴 - Data Class

`Object#equals`は参照値の比較を行っているので、  
単なるクラス宣言だと

```kotlin
class Money(val value: Int) // お金を表す型

val moneyA = Money(100) // 100円
val moneyB = Money(100) // 100円

moneyA == moneyB
```

は `false` になる。  
<small>※kotlinの場合 `==` が `equals` と同じ</small>

---
class: middle, center

# 🤔🤔🤔

100円は100円でしょ...

---
class: middle, center

じゃあ自前で`equals`をオーバライドすると...

---
class: middle

```kotlin
class Money(val value: Int) {

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Money) return false

        if (value != other.value) return false

        return true
    }

    override fun hashCode(): Int {
        return value
    }

    override fun toString(): String {
        return "Money(value=$value)"
    }
    
}
```

---
class: middle, center

長い

---
class: middle

### Kotlinの特徴 - Data Class

`equals`を自前で実装すると、プロパティ数に比例して記述量が多くなる。  
また、`equals`をオーバライドする場合には、

* 一般契約 (反射的, 対称的, 推移的, 整合的, 非null性)

と呼ばれる「`equals`をオーバライドする場合の決まり事」に従う必要がある。 

<small>※一般契約に従わないと余裕でバグる（例えば`HashMap`や`HashSet`は一般契約に従ったクラスを扱うことを前提に設計されている）ので、IDEに自動生成してもらうのが良い。</small>


---
class: middle

### Kotlinの特徴 - Data Class

`data class`としてクラス定義することで、  
面倒な実装や制約のことを気にする必要がなくなる。

あとは `toString` が

```kotlin
println(Money(100).toString()) // => Money(value=100)
```

という感じで有用な文字列表現を返してくれるので嬉しい。


<small>ログに↓みたいなのが出力されてるシステム見たことアルヨ...</small>

```kotlin
com.example.Hoge@8a50f1cc
```

---
class: middle

### Kotlinの特徴 - Data Class

#### ~ `componentN` ~

`component1()`といった、「N番目のプロパティを取得する」メソッドが生成される。  
👉 「プロパティを別の変数にまとめて代入する」ことが可能となる。

<br>


```kotlin
data class User(val name: String, val age: Int, val gender: Gender)
```

```kotlin
// 名前 と 性別 だけ抽出
val user = User("Bob", 20, Gender.MAN)
val (name, _, gender) = user
```

```kotlin
// ラムダの引数に、名前と年齢だけを渡す
val users: List<User> = ...
users.map { (name, age) ->
    ...
}
```

---
class: middle

### Kotlinの特徴 - Data Class

この機能を使えば、擬似的な "多重戻り値" が実現できる。

```kotlin
data class User(val id: Long, val name: String, ...)

// 戻り値に data class
fun findById(id: Long): User = { ... }

// 擬似的な多重戻り値
val (_, name, ...) = findById(10L)
```

<br>

--

ただ...

---
class: middle

### Kotlinの特徴 - Data Class

この機能を使えば、擬似的な "多重戻り値" が実現できる。

```kotlin
data class User(val id: Long, val name: String, ...)
fun doSomthing(): User = {
    ...
    return User(id, name, ...)
}

// 擬似的な多重戻り値
val (_, name, ...) = doSomthing()
```

<br>

👉 順番にしか取り出せないのがネック...（プロパティ名を指定できるようにしてほしい）

---
class: middle

### Kotlinの特徴 - Data Class

この`componentN`、具体的には 

### 分解宣言(Destructuring Declarations)

という機能で、JSでいう分割代入に近い。  

<small>
※ちなみに、`componentN`というメソッド名にすると分解宣言が有効になるわけではなく、
`componentN`を`operator`修飾する必要がある。
</small>

```kotln
// 普通のクラスでも分割宣言を使いたい場合
class User(val name: String, val age: Int, val gender: Gender) {
    operator fun component1() = name
    operator fun component2() = age
    operator fun component3() = gender
}
```

<br>

👉 `operator` + `componentN` = 分解宣言

---
class: middle

### Kotlinの特徴 - Data Class

〜おまけ〜 

JSの分割代入は

```js
// 先頭だけ個別、残りは配列のまま分割代入
const arry = [1, 2, 3];
const [a, ...b] = array; // a = 1, b = [2, 3]

// キーワードで分割代入
const obj = { name: "田中", age: 20, gender: "man" };
const {name, gender} = obj; // name = "田中", gender = "man"
```

といった柔軟なことができるが、Kotlinの分割宣言は上記のようなことは出来ない。  
惜しい。


---
class: middle

### Kotlinの特徴 - Data Class

#### ~ `copy` ~

名前の通りインスタンスのコピーを行うメソッド。  
`copy`メソッドは一部のプロパティだけを変更したインスタンスを作成することができる。

```kt
data class User(val name: String, val age: Int, val gender: Gender)

// 20歳 男性 田中さん
val tanaka = User("田中", 20, Gender.MAN) 

// 色々あって姓が 佐藤 へ
val satoPh2 = tanaka.copy(name = "佐藤") 

// 色々あって、佐藤さんは30歳で女性へ
val satoPh3 = satoPh2.copy(age = 30, gender = Gender.WOMAN) 
```

---
class: middle

### Kotlinの特徴 - Data Class

`copy`メソッドが利用できると

1. DB等のデータストアから、条件に一致するデータを抽出
2. 抽出したデータの一部を変更して、データストアを更新
3. 1 のデータを使って後続の処理を実施

といったケースに対して容易に対応できる。  
プロパティ数が多い場合、インスタンスのコピーは面倒なので非常に有用なメソッド。  
※ `BeanUtils#copyProperties` みたいなのは、型安全じゃないので使いたくない

<br>

👉 特にimmutableなクラスだと尚更有用

---
class: middle

### Kotlinの特徴

Kotlinには他にも

* 文字列テンプレート
  * 文字列に変数を埋め込めるやつ
* 拡張関数
  * 既存クラスに新しいメソッドを生やすやつ
* 高階関数
  * 関数の引数や戻り値に関数を指定できるやつ
* Sealed Classes
  * 同一ファイル内でのみ継承可能

など、様々な機能が備わっているので、気になったら調べてみてください。  
どれも「こんなのがJavaに欲しかった」機能ばかりです。

---
class: middle

## まとめ

* 簡潔&効率的に書け、Java経験者の学習コストは低い
* null安全やdata classなど、有用な機能が豊富
* Kotlinはいいぞ

---
class: middle

## Kotlinはいいぞ

---
class: middle, center

## ご静聴、ありがとうございました

質問があれば答えます！

---
class: middle

## Q & A

---
class: middle

### Q & A

事前にKotlinについての質問を受け付けたので、それに回答します。

---
class: middle

## Q. Javaよりもパフォーマンスはいいのか？

---
class: middle

### Q. Javaよりもパフォーマンスはいいのか？

## A. 変わらない（らしい）

<br>

ただ、Kotlinのラムダが少し遅いらしい？

<br>

...札束で殴ればエエねん。

---
class: middle

## Q. セキュリティ面についてはどう？

---
class: middle

### Q. セキュリティ面についてはどう？

## A. 今のところ、Kotlin特有の脆弱性等は無さそう

<br>

個人的に調べた範囲では、特にセキュリティホール等の情報は見受けられなかった。  
あるとすれば、JVMやフレームワーク周りかな？

---
class: middle

## Q. バージョンアップ等のメンテのやりやすさは？

---
class: middle

### Q. バージョンアップ等のメンテのやりやすさは？

## A. 楽だと思います。

<br>

勿論バージョンアップに伴って、プロダクトコードが正しく動作するかの確認は必要。  
Javaと同じく、Kotlinは後方互換性を大事にしているみたいなので、  
「バージョンアップで動かなくなる」ということは心配しなくていいはず。


---
class: middle

## 参考

* 公式
  * [Kotlin Programming Language](https://kotlinlang.org/)
* Javaとの比較系
  * [JavaプログラマのためのKotlin入門 - Qiita](https://qiita.com/koher/items/bcc58c01c6ff2ece658f)
  * [【Kotlin】【Java】Kotlin Javaの比較メモ - Qiita](https://qiita.com/farman0629/items/f959a4ff791f26b33fc3)
  * [JavaプログラマがKotlinで便利だと感じること - Qiita](https://qiita.com/koher/items/cb91dbbff9b14575f498#destructuring-declaration)
* null安全について
  * [null安全を誤解している人達へのメッセージ - Qiita](https://qiita.com/omochimetaru/items/ee29d4c6eb0d78f02b15)
  * [null安全でない言語は、もはやレガシー言語だ - Qiita](https://qiita.com/koher/items/e4835bd429b88809ab33)
* その他
  * [Kotlinアンチパターン - SlideShare](https://www.slideshare.net/RecruitLifestyle/kotlin-87339759)
  * [生粋のKotlin LoverによるLINEのKotlinの話 - SlideShare](https://www.slideshare.net/linecorp/kotlin-loverlinekotlin)

        </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript"></script>
    <script type="text/javascript">
      var slideshow = remark.create({
        ratio: '4:3'
      });
    </script>
  </body>

  </html>
